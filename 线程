*******
 一、线程
   1、概念
         线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。
     一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
         在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。
         线程是独立调度和分派的基本单位。
         同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理、用户ID和组ID等
         但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。
         一个进程可以有很多线程来处理，每条线程并行执行不同的任务。
         LWP： 轻量级的进程，本质是进程（在Linux环境下）
         进程：独立地址空间，拥有PCB
         线程：也有PCB，但没有独立的地址空间（共享）
   2、线程与进程的区别：
         是否共享地址空间，举例：独居（进程），合租（线程）。
         Linux下：线程：最小的执行单位
         进程：最小分配资源单位，可看成是只有一个线程的进程。
         
   3、Linux内核线程实现原理
        1、轻量级进程，也有PCB，创建线程使用的底层函数和进程一样，都是clone
        2、从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的
        3、进程可以蜕变成线程
        4、线程可以看做寄存器和栈的集合
        5、在linux下，线程是最小的执行单位，进程是最小的分配资源单位
        
     查看LWP号：ps-Lf pid 查看指定线程的lwp号。 
       
   4、线程非共享资源
      1、线程ID
      2、处理器现场和栈指针（内核栈）
      3、独立的栈空间（用户空间栈）
      4、errno变量
      5、信号屏蔽字
      6、调度优先级
  5、线程优、缺点  百度
  
  6、线程控制函数
    1）创建子线程
    #include<pthread.h>
    创建用户级线程：
     int pthread_create(pthread_t * thread, const pthread_attr_t * attr, void *(*start_routine)(void *), void *arg); //创建一个线程 attr为函数名
          成功：0；失败：error number 
     参数：
       pthread_t: 在 linux 中，typedef unsigned long int pthread_t
       参数1：传出参数，保存系统为我们分配好的线程ID
       参数2：通常为NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数
       参数3：函数指针，指向线程主函数（线程体），该函数运行结束，则线程结束
       参数4：线程主函数执行期间所使用的参数。
       
    返回当前用户级线程的线程标识符：
     pthread_t pthread_self(void);  
    2）创建循环线程
       int N,i;
       pthread_t pth;
     
     void func(void *arg)
      { 
       //还可以实现其他功能
        int i= (int)arg;
        printf("%dth pthread id = %lu,pid = %d\n",i+1,pthread_self(),getpid());
        //sleep();
        return NULL;
      }
       
       for (i = 0;i<N;i++)
        {
          int ret = pthread_create(&pth,NULL,func, (void *)i); //func为函数名， (void *)i 不是(void*)&i,传入地址的话，在函数func()中，打印出来的是父线程中i那个的地址所存的值
          if(ret!=0)
          { 
           fprintf(stdre,"pthread create fail,id is= %s\n",strerror(ret));
           exit(1);
          }
        }
     3)、线程共享全局变量
       
     4）、线程退出
       void pthread_exit(void *retval);将调用该函数的线程退出
       return；返回到调用者那里去
       exit;  将进程退出
      
  7、pthread_join()函数
       pthread_join使一个线程等待另一个线程结束。
　　代码中如果没有pthread_join；主线程会很快结束从而使整个进程结束，从而使创建的线程没有机会开始执行就结束了。加入pthread_join后，主线程会一直等待直到等待的线程结束自己才结束，使创建的线程有机会执行。
　　所有线程都有一个线程号，也就是threadid，其类型为pthread_t。 通过调用pthread_self()函数可以获得自身的线程号。
　　如果你的主线程，也就是main函数执行的那个线程，在你其他线程退出之前就已经退出，那么带来的bug则不可估量。通过pthread_join函数会让主线程阻塞，直到所有线程都已经退出。
　　int pthread_join(pthread_t thread, void **value_ptr);
    thread：等待退出线程的线程号。
    value_ptr：退出线程的返回值。
 8、pthread_detach()函数
     pthread_detach()函数使线程进行分离，并自己结束，自动清理系统线程
    pthread_attr_t  attr;
　　pthread_attr_init(&attr);
　　pthread_attr_setdetachstate(&attr,  PTHREAD_CREATE_DETACHED);
　　pthread_create(&pthreadid,  &attr,  myprocess,  &arg);
 警告：
　　在线程设置为joinable后，可以调用pthread_detach()使之成为detached。但是相反的操作则不可以。还有，如果线程已经调用pthread_join()后，则再调用pthread_detach()则不会有任何效果。
  9、pthread_cancel()函数
    线程可以通过自身执行结束来结束，也可以通过调用pthread_exit()来结束线程的执行。另外，线程甲可以被线程乙被动结束。这个通过调用pthread_cancel()来达到目的。
int pthread_cancel(pthread_t thread);
函数调用成功返回0。
    线程也可以自己取消，通过设置一个取消点
 取消点
   根据POSIX标准，pthread_join()、 pthread_testcancel()、pthread_cond_wait()、 pthread_cond_timedwait()、sem_wait()、sigwait()等函数以及read()、write()等会引起阻塞的系统调用都是Cancelation-point，
   而其他pthread函数都不会引起Cancelation动作。但是pthread_cancel的手册页声称，由于LinuxThread库与C库结合得不好，因而目前C库函数都不是Cancelation-point；但CANCEL信号会使线程从阻塞的系统调用中退出，并置EINTR错误码，
   因此可以在需要作为Cancelation-point的系统调用前后调用pthread_testcancel()，从而达到POSIX标准所要求的目标，即如下代码段：   
   pthread_testcancel();   
   retcode = read(fd, buffer,length);   
   pthread_testcancel();
    
10、修改线程栈空间大小
   
二、线程同步
   1、概念
      线程同步是为了确保线程安全，所谓线程安全指的是多个线程对同一资源进行访问时，有可能产生数据不一致问题，导致线程访问的资源并不是安全的。
      （如果多线程程序运行结果和单线程运行的结果是一样的，且相关变量的值与预期值一样，则是线程安全的。）
  1）、线程安全
   概述：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，
         或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

   注：这意味着如若要实现线程安全，代码本身必须要封装所有必要的正确性保障手段（比如锁的实现），以确保程序无论在多线程环境下如何调用该方法，将始终保持返回正确的结果。
  
   所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。
   2）、数据混乱原因
      资源共享（独享资源则不会）
      调度随机（意味着数据访问会出现竞争）
      线程间缺乏必要的同步机制。
     
   前两点是不能改变，预提高数据效率，传递数据，资源必须共享。只有共享资源，就一定会出现竞争。   
   所以只能从第三点着手解决，使多个线程在访问共享资源的时候，出现互斥。
   
  2、互斥量
   互斥量表现互斥现象的数据结构，也被当作二元信号灯。一个互斥基本上是一个多任务敏感的二元信号，它能用作同步多任务的行为，它常用作保护从中断来的临界段代码并且在共享同步使用的资源。
   Mutex本质上说就是一把锁，提供对资源的独占访问，所以Mutex主要的作用是用于互斥。Mutex对象的值，只有0和1两个值。这两个值也分别代表了Mutex的两种状态。
   值为0, 表示锁定状态，当前对象被锁定，用户进程/线程如果试图Lock临界资源，则进入排队等待；值为1，表示空闲状态，当前对象为空闲，用户进程/线程可以Lock临界资源，之后Mutex值减1变为0。

Mutex可以被抽象为四个操作：

- 创建 Create

- 加锁 Lock

- 解锁 Unlock

- 销毁 Destroy

Mutex被创建时可以有初始值，表示Mutex被创建后，是锁定状态还是空闲状态。在同一个线程中，为了防止死锁，系统不允许连续两次对Mutex加锁(系统一般会在第二次调用立刻返回)。
也就是说，加锁和解锁这两个对应的操作，需要在同一个线程中完成。
  
 主要函数：
  pthread_mutex_t mutex; //定义锁
    pthread_mutex_init(); //初始化函数
    pthread_mutex_destroy();//销毁
    pthreaf_mutex_lock(); //加锁
    pthread_mutex_unlock();//解锁
    
 1）、加锁与解锁
   lock和unlock
   在访问共享资源前加锁，访问结束后立即解锁，锁的“粒度”越小越好。
   
 2）、死锁
   1、线程试图对同一个互斥量A加锁两次
   2、线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁





