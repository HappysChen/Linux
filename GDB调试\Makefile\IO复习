一、gdb -- 命令
    1、前提条件：可执行文件必须包含调试信息 gcc -g
    2、gdb 文件名 -- 启动gdb调试
    3、查看代码的命令：
       当前文件： 
         list 行号（函数名）
       指定文件：
         list 文件名：行号（函数名）
    4、设置断点
      当前文件：
        b 行号（函数名）
      指定文件：
        b 文件名：行号（函数名）
      设置条件断点：
        b 行号：if value==23
      查看断点信息：
       info b
      删除断点：
        d 断点的信息
   5、开始调试
      只执行一行代码：start
        继续执行停在断点处： continue -- c
      直接停在断点处：run -- r  
   6、单步调试
      进入到函数体：step -- s
        跳出函数体：finish（如果在循环处有断点，需要将断点删除）
      不进入函数体：next -- n 
   7、追踪变量：
      自动打印变量的值：display 变量名
      取消变量的追踪 ：undisplay 编号
        获取编号  ：info display
      手动打印变量的值：print -- p
      获取变量对应的类型：ptype
   8、跳出循环：u
   9、退出gdb：quit
 
二、Makefile 
1、一个规则
  三要素：目标、依赖、命令
  目标：依赖
       命令
  
  1）第一条规则是用来生成终极目标
    1>.如果规则中的依赖不存在，向下寻找其他的规则
    2>更新机制：比较目标文件和依赖文件的时间
2、两个函数
  1）查找指定目录下，指定类型的文件
     src = $(wildcard ~/aa/*.c)
  2) 匹配替换函数
     obj=$(patsubst %.c, %.o, $(src))
3、三个自变量
   1）$<:规则中的第一个依赖
   2）$^:规则中的所有依赖
   3）$@:规则中的目标
   只能在规则中的命令中使用
4、模式规则
   %.o:%.c
     gcc -c $< -o $@
 
三、Linux系统IO函数
  1、文件描述符
    int类型
    一个进程最多可打开多少文件
  2、pcb
    进程控制块
    在其中有一个文件描述符表--- 数组[1024]
    
  3、虚拟地址空间
    用户区、内核区
   用户区：
      代码段
      已经初始化的全局变量
      未被初始化的全局变量
      堆 -- 从下往上
      共享库
      栈 - 从上往下
      环境变量
      内核区
      
   4、读大文件 -- 写入另一个文件
   
 两种方式：
    read write -- 每次读1个byte
    getc putc  -- 每次读一个byte -- 效率高
      标准c库函数，内部有一个缓冲区
      
 
 
 
 
 
 
 
 
 



