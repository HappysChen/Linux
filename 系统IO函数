  系统IO函数
一、 概念
   文件描述符
   PCB
   c库函数的IO缓冲区

系统调用：
  LINux内核提供了一组用户进程与内核进行交互的接口对文件和设备进行访问控制，这些接口被称为系统调用。
系统调用对于应用程序最大的作用在于：
  以同意的形式：为应用程序提供了一组文件访问的抽象接口，因共用程序不需要关心文件的具体类型，也不用关心其内部实现细节。 

常用的系统调用IO函数有：
另外介绍：Linux系统中的man是系统内部分页手册,可用于查询函数在那一页

二、open
   open用于创建一个新文件或打开一个已有文件，返回一个非负的文件描述符fd。
   0、1、2为系统预定义的文件描述符，分别代表STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO。
  
  flags参数一般在O_RDONLY、O_WRONLY和O_RDWR中选择指定一个，还可以根据需要或上以下常值：
    O_CREAT：若文件不存在则创建它，此时需要第三个参数mode，mode可设的值及含义如下图所示。
    O_APPEND：每次写时都追加到文件的尾端
    O_NONBLOCK：如果pathname对应的是FIFO、块特殊文件或字符特殊文件，则该命令使open操作及后续IO操作设定为非阻塞模式
    
   打开方式：
    必选项： flags
       O_RDONLY  只读
       O_WROMLY  只写
       O_RDWR    读写
    可选项：
       O_CREAT
       文件权限：本地存在一个掩码
          文件的实际权限
          给定的权限
          本地掩码
         &
          实际的文件权限
          比如：777
               111111111
               本地掩码取反再做按位操作
       O_TRUNC 
       O_EXCL
       O_APPEND
       
   #include<sys/types.h>
   #include<sys/stat.h>
   #include<fcntl.h>
   //成功返回文件描述符，失败返回-1
   int open(const char *pathname, int flags,... /* mode_t mode */);
   
   
       
       
 三、read
read用于从打开文件中读数据。

#include <unistd.h>

//成功返回读到的字节数；若读到文件尾则返回0；失败返回-1
ssize_t read(int fd, void *buf, size_t count);
read操作从文件的当前偏移量处开始，在成功返回之前，文件偏移量将增加实际读到的字节数。
有几种情况可能导致实际读到的字节数少于要求读的字节数：

读普通文件时，在读到要求字节数之前就到达了文件尾。例如，离文件尾还有30字节，要求读100字节，则read返回30，下次在调用read时会直接返回0
从网络读时，网络中的缓冲机制可能造成返回值少于要求读的字节数，解决办法在网络编程专题中再讲
    
 四、write

write用于向文件写入数据。

#include <unistd.h>

//成功返回写入的字节数，失败返回-1
ssize_t write(int fd, const void *buf, size_t count);
write的返回值通常与参数count相同，否则表示出错。
对于普通文件，write操作从文件的当前偏移量处开始
若指定了O_APPEND选项，则每次写之前先将文件偏移量设置到文件尾
成功写入之后，文件偏移量增加实际写的字节数。
    
 #include<stdio.h>
 #include<stdlib.h>
 #include<sys/stat.h>
 #include<sys/types.h>
 #include<unistd.h>
 #include<fcntl.h>
 
 int main()
 {
   //打开已经存在的文件
   int fd = open("test.sh",O_RDONLY);
   if(fd == -1)
   {
     perror("read file");
     exit(1);
   }
   //创建一个新的文件
   int fd1=open("myword",O_CREAT|O_WRONLY,0664);
   if(fd1 == -1)
   {
     perror("create file");
     exit(1);
   }
   //read file 
   char buf[2048]={0};
   int count = read(fd,buf,seizeof(buf));
   if(count ==-1)  //读取失败
   {
    perror("read");
    exit(1);
   }
   //读取成功
   //写入另一个文件
   while(count) //循环读取
   {
   //数据写入新文件
    int ret = write(fd1,buf,count);
    printf("write bytes: %d\n",count);
    count = read(fd,buf,seizeof(buf));
   }
   
   close (fd);
   close(fd1);
 }
 
    
    
 五、lseek
 lseek用于设置打开文件的偏移量。

#include <sys/types.h>
#include <unistd.h>

//成功返回新的文件偏移量，失败返回-1
off_t lseek(int fd, off_t offset, int whence);
对offset的解释取决于whence的值：

若whence == SEEK_SET，则将文件偏移量设为距文件开头offset个字节，此时offset必须为非负
若whence == SEEK_CUR，则将文件偏移量设为当前值 + offset，此时offset可正可负
若whence == SEEK_END，则将文件偏移量设为文件长度 + offset，此时offset可正可负
注意：

lseek仅将新的文件偏移量记录在内核中，它并不引起任何IO操作，因此它不是系统调用IO，但该偏移量会用于下一次read/write操作
管道、FIFO和套接字不支持设置文件偏移量，不能对其调用lseek
  
   #include<stdio.h>
 #include<stdlib.h>
 #include<sys/stat.h>
 #include<sys/types.h>
 #include<unistd.h>
 #include<fcntl.h>
 
 int main()
 {
   //打开已经存在的文件
   int fd = open("test.sh",O_RDONLY);
   if(fd == -1)
   {
     perror("read file");
     exit(1);
   }
   //将指针指向文件的末尾
   int ret =lseek(fd,0,SEEK_END);
   printf("return value %d \n",ret);
   //文件拓展
   ret =lseek(fd,2000,SEEK_END); //在文件第2000处拓展
   printf("return value  %d\n",ret);
   //还要进行写操作
   write(fd,"a",1);
   close(fd);
   return 0;
   
  }
  
 六、close
close用于关闭一个已打开文件。

#include <unistd.h>

//成功返回0，失败返回-1
int close(int fd);
进程终止时，内核会自动关闭它所有的打开文件，应用程序经常利用这一点而不显式关闭文件。
 
       
   
   
   
