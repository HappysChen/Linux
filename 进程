一、进程
  1、概念
      指计算机中已运行的程序；程序本身只是指令、数据及其组织形式的描述，相当于一个名词，进程才是程序（那些指令和数据）的真正运行实例，
  现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。
  同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机体系结构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。   
  
用户下达运行程序的命令后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突。

进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及I/O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。

1）进程与线程的区别：进程是计算机管理运行程序的一种方式，一个进程下可包含一个或者多个线程。线程可以理解为子进程。

2）进程之间是相互独立的，但进程A打开之后，通过MMU进行映射，在通过在物理内存中开辟一个空间，若打开同一对象，形成进程B，即进程A和进程B是由同一个对象打开而来，也需要MMU来映射到物理内存中，
但物理内存开辟的空间与进程A的是不一样的，两个进程的PCB共享同一个内核空间，但他们都是不同的PCB。

3）MMU（内存管理单元）的作用：
    完成物理内存和虚拟内存映射
    修改内存的访问级别

CPU和MMU：
  MMU是CPU的一部分
  存储介质：网络->硬盘->内存->cache(缓存空间）->寄存器
  当程序运行的时候，CPU中的预取器在缓存空间中获取程序指令，然后传给译码器，通过译码，识别程序的指令，然后传给算数逻辑单元进行运算，最后回写到寄存器堆中，这就是CPU完成的
  这个过程中，当程序运行时，MMU开始工作，但计算机取到指令就不需要MMU了。

2、进程控制块PCB
  每个进程在内核中都有一个进程控制块来维护进程相关的信息，Linux内核的进程控制快是task_struct结构体。
  包含：
   进程id:系统中每个进程都有一个id,在C语言中用pid_t类型表示，其实就是一个非负整数；
   进程状态：就绪、运行、堵塞、停止等状态
   
    进程在运行时，状态（state）会改变。所谓状态，就是指进程目前的动作：
    新生（new）：进程新产生中。
    运行（running）：正在运行。
    等待（waiting）：等待某事发生，例如等待用户输入完成。亦称“阻塞”（blocked）
    就绪（ready）：排班中，等待CPU。
    结束（terminated）：完成运行。
    
   进程切换时需要保护和恢复一些CPU寄存器
   描述虚拟地址空间的信息：与MMU有关
   描述控制终端的信息
   当前工作目录
   umask掩码：保护或修改文件的权限
   文件描述符表，包含很多指向file结构体的指针
   和信号相关的信息
   用户id和组id
   会话session和进程组
   进程可以使用的资源上限(Resource limit）
   
 3、环境变量
    指在操作系统中用来指定操作系统运行环境的一些参数。
     字符串（本质）、有统一的格式：名=值[:值]、 值用来描述进程环境信息
    操作函数：
    getenv(); // 获取环境变量
    setenv(); //修改或添加环境变量
    unsetenv(); //删除环境变量
    
 4、进程控制 计算机系统书 P513
    1）获取进程
       每个进程都一个唯一的ID（PID），getpid函数返回调用进程的PID，getppid函数返回它的父进程的PID（创建调用进程的进程）
       头文件：#include<sys/types.h>
               #include<unistd.h>
               pid_t getpid(void);
               pid_t getppid(void);
         
    2)创建进程
    父进程可以调用fork()创建一个新的运行子进程。
      #include<sys/types.h>
      #include<unistd.h>
      
      pid_t fork(void);
      
     创建循环进程用 for(int i=0;i<N;i++)
                     pid =fork();
       会达不到效果。
      for(i=0;i<N;i++)
      {
        pid = fork();
        if(pid== -1)
        {
          printf("fork error\n");
          exit(1);
        }
        else if(pid ==0)
        {
          break;
        }
      }
      if(i<N)
      {
       printf("child fork, pid= %u, ppid = %u\n",getpid(),getppid());
      }
      else 
      {
        printf("parent fork, pid= %u, ppid = %u\n",getpid(),getppid());
      }
               
     3)、进程共享
       父子进程之间在fork后：
       父子进程相同之处：全局变量、data、堆、栈、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式等
       父子进程不同之处：进程ID、fork返回值（父进程返回大于0，子进程等于0）、父进程ID，进程运行时间、闹钟（定时器），未决信号集
       ****父子进程间遵循：读时共享写时复制的原则。
       父子进程是并发运行的独立进程，相同但独立的地址空间。  
               
   5、gdb调试
     使用：首先编译时：gcc myfork.c -g
           使用 list 列出程序
           输入 l设置断点
           程序运行使用：run
           单独执行： start
           下一步执行输入：n
           若要设置跟踪的子进程：set follow-mode child
           设置跟踪父进程：   set follow-mode parent
           设置跟踪都要在fork函数调用之前设置才有效.
           设置断点:b 行号 条件    
   
   6、exec函数
         fork创建子进程后与父进程执行同样的代码（也可能是不同分支的程序），子进程调用exec函数来执行另一个程序，当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序代替，、
     从新程序的启动历程开始执行，调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。
       1. 当进程不需要再往下继续运行时，调用exec函数族中的函数让自己得以延续下去。
       2. 如果当一个进程想执行另一个可执行程序时，可以使用fork函数先创建一个子进程，然后通过子进程来调用exec函数从而实             现可执行程序的功能。
       #include <unistd.h>

       extern char **environ;

       int execl(const char *path, const char *arg, .../* (char  *) NULL */);
       int execlp(const char *file, const char *arg, .../* (char  *) NULL */);
       int execle(const char *path, const char *arg, ...
                       /*, (char *) NULL, char * const envp[] */);
       int execv(const char *path, char *const argv[]);
       int execvp(const char *file, char *const argv[]);
       int execvpe(const char *file, char *const argv[],char *const envp[]);
     
     l表示命令行参数列表、p表示PATH环境变量、v表示使用参数数组、e使用环境变量数组。
      
      1）、execl函数
       加载一个进程，借助“路径+程序名”来加载
       execl("/bin/ls", "ls", "-l", NULL);
       
      2）、execv函数
        char *argv[] = {"ls", "-l", NULL};
        execv("/bin/ls", argv);
      
      3）、execlp函数
        加载一个进程，借助PATh环境变量
        execlp("ls","ls","-l",NULL)   成功无返回，失败：-1
        该函数通常用来调用系统程序：如 ls 、 date 、 cp、cat命令等 
  
  7、回收子进程     
     首先了解孤立子进程和僵尸进程
        孤立子进程：指在父进程结束比子进程要早，就只剩子进程还没结束，内核会安排init进程成为它的孤儿进程的养父
        僵尸进程：一个终止了但还未被回收的进程为僵尸进程。
     1）回收进程
   wait 函数  P516
         一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，
     如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用Wait或Waitpid获取这些信息，然后彻底清除掉这个进程。
        父进程可以调用wait函数可以回收子进程终止信息。其功能为：
        <1>阻塞等待子进程退出
        <2>回收子进程残留资源
        <3>获取子进程结束状态(退出原因)
        pid_t wait(int *status) 成功：清理掉的子进程ID：失败：-1（没有子进程）
     
     当进程终止时，操作系统的隐式回收机制：关闭所有文件描述符、释放用户空间分配的内存，内核的PCB仍存在，其中保存改进程的退出状态。(正常终止->退出值；异常终止->终止信号)
     可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因，可分为三组：
        <1> WIFEXITED（status）为非0 ->进程正常结束
            WEXITSTATUS（status）如上宏为真，使用此宏 ->获取进程退出状态(exit的参数)
       
       <2> WIFSIGNALED(status)为非0 - > 进程异常终止
            WTERMSIG(status)如上宏为真，使用此宏 -> 取得使进程终止的那个信号的编号
       
       <3> WIFSTOPPED(status)为非0 ->进程处于暂停状态 (不太重要)
            WSTOPSIG(status)如上宏为真，使用此宏 -> 取得使进程暂停的那个信号的编号
            WIFCONTINUED(status) 为真 ->进程暂停后已经继续运行
      
       waitpid()函数
         作用跟wait函数一样，一个进程可以调用waitpid函数来等待它的子进程终止或者停止.
         与wait函数不同，waitpid函数可以设置不会产生堵塞，wait函数会一直等到进程结束终止才回收。
        waitpid(pid_t pid, int *status, int options)   返回:成功，返回清理的子进程PID，如果失败，则返回-1(无子进程)
          参数: pid 
             >0 回收指定ID的子进程
             -1 回收父进程中所有的子进程（相当于wait）
             0  回收和当前调用waitpid一个组的所有子进程
             <-1 回收指定进程组内的任意子进程
          返回0：参3为WNOHANG，且子进程正在运行。
          
      注意：一次Wait或Waitpid调用只能清理一个子进程 ，清理多个子进程应使用循环    
          
  8、进程间通信 IPC  
    进程之间不能直接通信，交换数据必须通过内核，在内核中开辟一块缓存区，进程1把数据从用户空间拷到内核缓冲区，进程2在从内核缓冲区把数据读走，内核提供的这种机制成为进程间通信。
      1）管道
          pipe
          管道一般读写行为
      2)信号FIFO: (有名管道) 开销最小
          有用于非血缘关系进程间通信
      3）内存共享：  无血缘关系
         mmap
         函数的参数使用注意事项
         用于非血缘关系进程间通信
      4) 本地套接字  最稳定
  
  1）管道： (使用最简单)
     是一系列将标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入。 每一个链接都由匿名管道实现[来源请求]。管道中的组成元素也被称作过滤程序。
      作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道，有如以下特质：
      1、其本质是一个伪文件（实为内核缓冲区）
      2、由两个文件描述符引用，一个表示读端、一个表示写端
      3、规定数据从管道的写端流入管道，从读端流出
     原理：管道实为内核使用唤醒队列机制，借助内核缓冲区（4K）实现
     局限性：
       1）数据自己读不能自己写
       2）数据一旦被读走，便不在管道中存在，不可反复读取
       3）由于管道采用半双工通信方式。因此，数据只能在一个方向上流动
       4）只能在有公共祖先的进程间使用管道
     
     创建管道函数pipe()
       int pipe(int pipefd[2]);  成功：0 ；失败：-1 设置 errno
       函数调用成功返回r/w 两个文件描述符。无需open，但需手动close。规定：fd[0]-> r ;fd[1]-> w
       向管道文件读写数据实质是在读写内核缓冲区。
       用read() write()函数进行读写操作
      
     读管道 ：管道中有数据 read返回实际读到的字节数
                   无数据：写端全关闭：read返回0
                          仍有端口打开：阻塞等待
     写管道：读端全关闭：进程异常终止（SIGPIPE信号）
             有读端打开：管道未满：写数据，返回写入字节数
                        管道已满：阻塞（少见）
     获取管道缓冲区大小 ：命令：ulimit -a
                        
   2）FIFO
     命名管道（Linux基础文件类型）
     
     创建：命令：mkfifo,函数：mkfifo:参数：name;mode：8进制
                                  返回值：成功：0，失败：-1 设置errno
     无血缘关系进程间通信： 使用到——》FIFO
                           可多读端，多写端
      
   3）共享内存映射    P580
     linux将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容 ，成为内存映射。
     可以映射到的类型：
         1、Linux文件系统中的普通文件：一个区域可以映射到一个普通文件磁盘文件的连续部分。文件区可以分成页大小的片，每一片包含一个虚拟页面的初始内容。
         2、匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零，
         磁盘和内存之间并没有实际的数据传送。因此有时，映射到匿名文件的区域中的页面有时也叫请求二进制零的页。
         不管哪种情况，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件之间换来换去，交换文件也叫做交换空间或交换区域。
         在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。
      
      1、mmap()函数 P585  
        Linux进程使用mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中。
        #include<unistd.h>
        #include<sys/mman.h>
        
        void *mmap(void *start ,size_t length, int port , int flags, int fd, off_t offset); 
          返回：成功：指向映射区域的指针，失败：MAP_FALED(-1)
        参数：
          start : 建立映射区的首地址，由Linux内核指定，使用时，直接传递给 NULL
          length: 创建的映射区的大小
          port  :包含描述新映射区的虚拟内存区域的访问权限位(即在相应区域结构中的vm_port位)
                 PROT_EXEC:可以被CPU执行的指令组成
                 PROT_READ:这个区域内的页面可读
                 PROT_WRITE:这个区域内的页面可写
                 PROT_NONE:这个区域内的页面不能被访问
          flags : 由描述被映射对象类型的位组成。标志位参数（常用于设定更新物理区域、设置共享、创建匿名映射区）
                 MAP_SHARED:会将映射区所做的操作反映到物理设备（磁盘）上。(共享对象）
                 MAP_PRIVATE:映射区所做的修改不会反映到物理设备。 被映射的对象是一个私有的、写时复制的对象
                 MAP_ANON标记位，被映射的对象是一个匿名对象，相应的虚拟页面是一个请求二进制零的。
          fd  :  用来建立映射区的文件描述符
          offset:映射文件的偏移(4K的整数倍）
      **认识一个新函数：
          ftruncate（）函数会将参数fd指定的文件大小改为参数length指定的大小
          定义函数 int ftruncate(int fd,off_t length);
          ftruncate()会将参数fd指定的文件大小改为参数length指定的大小。
          参数fd为已打开的文件描述词，而且必须是以写入模式打开的文件。
          如果原来的文件大小比参数length大，则超过的部分会被删去。
          返回值
          执行成功则返回0，失败返回-1，错误原因存于errno。
      
      munman函数 删除虚拟内存的区域
        #include<unistd.h>
        #include<sys/mman.h>
        
        int munmap(void *start ,size_t length) ; munmap 函数从删除从虚拟内存start开始的，由接下来length字节组成的区域。接下来对已删除区域的引用会导致段错误。
         
                 
       
       
       
       
       
       


